**SENG 438 - Software Testing, Reliability, and Quality**

**Lab. Report #3 – Code Coverage, Adequacy Criteria and Test Case Correlation**

| Group \#:                | 30  |  
| ------------------------ | --- |
| Student Names:           |     |
| Tara Cherian             |     |
| Gashagaza Gisa Tchaka    |     |
| Salem Shadfan            |     |
| Joshua Koshy             |     |

(Note that some labs require individual reports while others require one report
for each group. Please see each lab document for details.)

# 1 Introduction

In this lab, we focused on analyzing code coverage to assess the effectiveness of our unit tests in JFreeChart. The objective was to measure different types of coverage, including statement coverage, branch coverage, and condition coverage, to ensure that our test cases exercised as much of the code as possible. By utilizing tools such as EclEmma for Java, we identified untested parts of the code and refined our test suite to maximize coverage. This report details our approach, findings, and lessons learned from conducting a thorough code coverage analysis.

# 2 Manual data-flow coverage calculations for X and Y methods

Before making any modifications, we ran our existing unit tests and recorded the initial coverage metrics for statement, branch, and condition coverage. This baseline helped us identify gaps where our tests were not covering all possible execution paths.

Using the coverage report generated by EclEmma, we examined the uncovered lines and branches to determine potential reasons for gaps in test coverage. Some methods had conditional logic that was not fully exercised, while others had error-handling cases that were not triggered by our initial tests.


# 3 A detailed description of the testing strategy for the new unit test

We used EclEmma and out of statement, branch, and condition coverage, only branch coverage was supported. We decided to replace statement and condition coverage with method and line coverage.
To improve overall coverage, we added new test cases targeting uncovered code, focusing on unreachable branches in conditional statements, exception handling paths, and edge cases that were previously overlooked

For example, in the Range.shift(Range base, double delta, boolean allowZeroCrossing) method, we observed that certain branches controlling the zero-crossing behavior were not covered. We introduced test cases specifically designed to trigger these conditions.


# 4 A high level description of five selected test cases you have designed using coverage information, and how they have increased code coverage

Text…

# 5 A detailed report of the coverage achieved of each class and method (a screen shot from the code cover results in green and red color would suffice)

Text…

# 6 Pros and Cons of coverage tools used and Metrics you report

Text…

# 7 A comparison on the advantages and disadvantages of requirements-based test generation and coverage-based test generation.

Text…

# 8 A discussion on how the team work/effort was divided and managed

Text…

# 9 Any difficulties encountered, challenges overcome, and lessons learned from performing the lab

Text…

# 10 Comments/feedback on the lab itself

Text…
### **Step 1: DU-Pairs Per Variable in Each Method**


#### **1. getCentralValue()**


<table>
  <tr>
   <td><strong>Variable</strong>
   </td>
   <td><strong>Def (Write)</strong>
   </td>
   <td><strong>Use (Read)</strong>
   </td>
   <td><strong>DU-Pair</strong>
   </td>
  </tr>
  <tr>
   <td>lower
   </td>
   <td>Class field
   </td>
   <td>Line 2
   </td>
   <td>(class field → return)
   </td>
  </tr>
  <tr>
   <td>upper
   </td>
   <td>Class field
   </td>
   <td>Line 2
   </td>
   <td>(class field → return)
   </td>
  </tr>
</table>



#### **2. calculateColumnTotal()**


<table>
  <tr>
   <td><strong>Variable</strong>
   </td>
   <td><strong>Def (Write)</strong>
   </td>
   <td><strong>Use (Read)</strong>
   </td>
   <td><strong>DU-Pair</strong>
   </td>
  </tr>
  <tr>
   <td>total
   </td>
   <td>Line 2
   </td>
   <td>Line 9
   </td>
   <td>(2 → 9)
   </td>
  </tr>
  <tr>
   <td>rowCount
   </td>
   <td>Line 3
   </td>
   <td>Line 5
   </td>
   <td>(3 → 5)
   </td>
  </tr>
  <tr>
   <td>n
   </td>
   <td>Line 7
   </td>
   <td>Line 8
   </td>
   <td>(7 → 8)
   </td>
  </tr>
</table>



---


### **Step 2: Test Coverage of DU-Pairs**


#### **Test Cases for calculateColumnTotal()**


<table>
  <tr>
   <td><strong>Test Case</strong>
   </td>
   <td><strong>Covers DU-Pair (total: 2 → 9)</strong>
   </td>
   <td><strong>Covers DU-Pair (rowCount: 3 → 5)</strong>
   </td>
   <td><strong>Covers DU-Pair (n: 7 → 8)</strong>
   </td>
  </tr>
  <tr>
   <td>testCalculateColumnTotal_ValidColumn()
   </td>
   <td>✅
   </td>
   <td>✅
   </td>
   <td>✅
   </td>
  </tr>
  <tr>
   <td>testCalculateColumnTotal_OutOfBoundsColumnNegative()
   </td>
   <td>✅
   </td>
   <td>✅
   </td>
   <td>❌
   </td>
  </tr>
  <tr>
   <td>testCalculateColumnTotal_EmptyData()
   </td>
   <td>✅
   </td>
   <td>❌
   </td>
   <td>❌
   </td>
  </tr>
  <tr>
   <td>testCalculateColumnTotal_BoundaryFirstColumn()
   </td>
   <td>✅
   </td>
   <td>✅
   </td>
   <td>✅
   </td>
  </tr>
  <tr>
   <td>testCalculateColumnTotal_BoundaryLastColumn()
   </td>
   <td>✅
   </td>
   <td>✅
   </td>
   <td>✅
   </td>
  </tr>
</table>



#### **Test Cases for getCentralValue()**


<table>
  <tr>
   <td><strong>Test Case</strong>
   </td>
   <td><strong>Covers DU-Pair (lower: field → return)</strong>
   </td>
   <td><strong>Covers DU-Pair (upper: field → return)</strong>
   </td>
  </tr>
  <tr>
   <td>testGetCentralValue_PositiveBounds()
   </td>
   <td>✅
   </td>
   <td>✅
   </td>
  </tr>
  <tr>
   <td>testGetCentralValue_NegativeBounds()
   </td>
   <td>✅
   </td>
   <td>✅
   </td>
  </tr>
  <tr>
   <td>testGetCentralValue_ZeroCrossingRange()
   </td>
   <td>✅
   </td>
   <td>✅
   </td>
  </tr>
  <tr>
   <td>testGetCentralValue_LowerBoundEqualsUpperBound()
   </td>
   <td>✅
   </td>
   <td>✅
   </td>
  </tr>
</table>



---


### **Step 3: DU-Pair Coverage Calculation**

Using the formula:

DU-Pair Coverage=DU-pairs covered/Total DU-pairs×100%


#### **For calculateColumnTotal()**



* **Total DU-Pairs** = 3
* **DU-Pairs Covered** = 2 (since n: 7 → 8 is missed in two tests)
* **Coverage**: 2/3×100=66.67%


#### **For getCentralValue()**



* **Total DU-Pairs** = 2
* **DU-Pairs Covered** = 2
* **Coverage**: 2/2×100=100%